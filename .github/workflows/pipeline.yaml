name: Build & Deploy Pipeline

on:
  pull_request:
    branches: ["*"]
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  # Required repository variables (set these in Repo Settings → Variables)
  REGISTRY_URL: ${{ vars.REGISTRY_URL }}
  REGISTRY_USERNAME: ${{ vars.REGISTRY_USERNAME }}
  REGISTRY_PASSWORD: ${{ vars.REGISTRY_PASSWORD }}
  KUBE_CONFIG_B64: ${{ vars.KUBE_CONFIG_B64 }}
  # Optional repository variables to control which image and k8s target to deploy
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}    # e.g. myorg/bobrossbot
  IMAGE_TAG: ${{ vars.IMAGE_TAG }}      # if not set, will fallback to the build pipeline's tag or commit
  K8S_NAMESPACE: ${{ vars.K8S_NAMESPACE }}
  K8S_DEPLOYMENT: ${{ vars.K8S_DEPLOYMENT }}
  K8S_CONTAINER_NAME: ${{ vars.K8S_CONTAINER_NAME }}
  # Optional Helm options
  HELM_RELEASE: ${{ vars.HELM_RELEASE }}
  HELM_EXTRA_ARGS: ${{ vars.HELM_EXTRA_ARGS }}

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set-tag.outputs.image_tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - id: meta
        name: Docker metadata
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=sha
            type=ref,event=branch
            type=ref,event=tag
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Install helm
        run: |
          set -eux
          HELM_VERSION=v3.12.0
          curl -LO "https://get.helm.sh/helm-$HELM_VERSION-linux-amd64.tar.gz"
          tar xzf "helm-$HELM_VERSION-linux-amd64.tar.gz"
          install -m 0755 linux-amd64/helm /usr/local/bin/helm
          helm version

      - name: Helm lint
        run: |
          helm lint ./helm

      - name: Log in to GHCR
        if: github.event_name == 'push'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build (and push on main/tags)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: ${{ github.event_name == 'push' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Set image tag output
        id: set-tag
        run: |
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy
    needs: build
    runs-on: ubuntu-latest
    if: >-
      github.event_name == 'workflow_dispatch'
      || (github.event_name == 'push' && github.ref == 'refs/heads/main')
      || github.event_name == 'pull_request'

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.REGISTRY_URL || secrets.REGISTRY_URL || 'ghcr.io' }}
          username: ${{ vars.REGISTRY_USERNAME || secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Install kubectl and helm
        run: |
          set -eux
          # Install kubectl
          KUBECTL_VERSION=$(curl -L -s https://dl.k8s.io/release/stable.txt)
          curl -LO "https://dl.k8s.io/release/$KUBECTL_VERSION/bin/linux/amd64/kubectl"
          install -m 0755 kubectl /usr/local/bin/kubectl

          # Install helm
          HELM_VERSION=v3.12.0
          curl -LO "https://get.helm.sh/helm-$HELM_VERSION-linux-amd64.tar.gz"
          tar xzf "helm-$HELM_VERSION-linux-amd64.tar.gz"
          install -m 0755 linux-amd64/helm /usr/local/bin/helm

      - name: Write kubeconfig
        env:
          KUBECONFIG_SECRET: ${{ secrets.KUBE_CONFIG_B64 || vars.KUBE_CONFIG_B64 || secrets.KUBECONFIG || '' }}
        run: |
          set -eux
          mkdir -p "$HOME/.kube"
          # If KUBECONFIG_SECRET is base64, decode; else write as-is
          if echo "$KUBECONFIG_SECRET" | base64 --decode > "$HOME/.kube/config" 2>/dev/null; then
            echo "Decoded base64 kubeconfig to $HOME/.kube/config"
          else
            echo "$KUBECONFIG_SECRET" > "$HOME/.kube/config"
          fi
          chmod 600 "$HOME/.kube/config"
          kubectl version --client || true
          kubectl cluster-info --request-timeout=60s || echo "cluster-info failed (cluster may be unreachable)"

      - name: Helm upgrade
        env:
          # Prefer explicit HELM_RELEASE or K8S_DEPLOYMENT, else computed at runtime below from GITHUB_REPOSITORY
          RELEASE: ${{ vars.HELM_RELEASE || vars.K8S_DEPLOYMENT || '' }}
          NS: ${{ vars.K8S_NAMESPACE || 'default' }}
          IMAGE_REGISTRY: ${{ vars.REGISTRY_URL || secrets.REGISTRY_URL }}
          IMAGE_NAME: ${{ vars.IMAGE_NAME }}
          TAG: ${{ github.event.inputs.image_tag || vars.IMAGE_TAG || needs.build.outputs.image_tag || 'latest' }}
          HELM_EXTRA_ARGS: ${{ vars.HELM_EXTRA_ARGS || '' }}
          # Run client-side dry-run for PRs to avoid requiring cluster access; production runs will be live
          DRY_RUN: ${{ github.event_name == 'pull_request' }}
          HELM_TIMEOUT: '10m'
          # Pass secrets from repository into Helm so chart can create the {{ .Release.Name }}-secrets Secret
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    
        run: |
          set -eux
          export KUBECONFIG="$HOME/.kube/config"
          # Compute IMAGE_REPO: prefer explicit IMAGE_NAME, otherwise fallback to github repo (owner/repo)
          if [ -n "${IMAGE_NAME}" ]; then
            IMAGE_REPO="${IMAGE_REGISTRY%/}/${IMAGE_NAME}"
          else
            # If IMAGE_REGISTRY already contains an owner (has a slash like ghcr.io/owner), only append the repo name
            if echo "${IMAGE_REGISTRY}" | grep -q '/'; then
              IMAGE_REPO="${IMAGE_REGISTRY%/}/${GITHUB_REPOSITORY##*/}"
            else
              IMAGE_REPO="${IMAGE_REGISTRY%/}/${GITHUB_REPOSITORY,,}"
            fi
          fi
          # Ensure lowercase and strip accidental double-slashes
          IMAGE_REPO=$(echo "${IMAGE_REPO}" | tr '[:upper:]' '[:lower:]' | sed 's#//*#/#g')
          echo "Using image repo: ${IMAGE_REPO}"
          # If RELEASE was not provided via vars, derive it from the repository name (owner/repo -> repo)
          if [ -z "${RELEASE}" ]; then
            RELEASE="${GITHUB_REPOSITORY##*/}"
          fi
          # Sanitize release: lowercase, replace invalid chars with '-', trim leading/trailing '-' and limit length
          RELEASE=$(echo "${RELEASE}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9.-]/-/g' | sed 's/^-*//; s/-*$//' | cut -c1-53)
          echo "Using Helm release name: ${RELEASE}"
          helm version
          kubectl version --client || true
          # Prefer the 'latest' tag for main branch deployments to match push tagging
          if [ "${GITHUB_REF}" = "refs/heads/main" ]; then
            echo "Main branch deployment detected — using tag 'latest'"
            TAG='latest'
          fi
          # Prepare secret args for Helm (contents are NOT echoed)
          HELM_SECRETS_ARGS=""
          if [ -n "${DISCORD_TOKEN}" ]; then
            HELM_SECRETS_ARGS="${HELM_SECRETS_ARGS} --set-string secrets.DISCORD_TOKEN='${DISCORD_TOKEN}'"
          fi
          if [ -n "${OPENAI_API_KEY}" ]; then
            HELM_SECRETS_ARGS="${HELM_SECRETS_ARGS} --set-string secrets.OPENAI_API_KEY='${OPENAI_API_KEY}'"
          fi

          if [ "${DRY_RUN}" = "true" ]; then
            echo "PR detected — linting & rendering chart client-side"
            # Lint and template locally to validate chart without contacting the cluster
            helm lint ./helm
            helm template "${RELEASE}" ./helm --namespace "${NS}" --set image.repository="${IMAGE_REPO}" --set image.tag="${TAG}" ${HELM_SECRETS_ARGS} ${HELM_EXTRA_ARGS} --debug
          else
            echo "Running pre-checks: helm lint and server-side dry-run (skipped on prod/main) with timeout ${HELM_TIMEOUT}"
            # Lint to ensure chart correctness
            helm lint ./helm
            # Only run server-side dry-run for non-prod branches (main is treated as prod)
            if [ "${GITHUB_REF}" != "refs/heads/main" ]; then
              echo "Non-prod branch detected — running server-side dry-run"
              helm upgrade --install "${RELEASE}" ./helm --namespace "${NS}" --create-namespace --set image.repository="${IMAGE_REPO}" --set image.tag="${TAG}" ${HELM_SECRETS_ARGS} --dry-run --debug --timeout ${HELM_TIMEOUT}
              echo "Server-side dry-run succeeded; proceeding with live upgrade"
            else
              echo "Prod branch detected (refs/heads/main) — skipping server-side dry-run"
            fi
            helm upgrade --install "${RELEASE}" ./helm --namespace "${NS}" --create-namespace --set image.repository="${IMAGE_REPO}" --set image.tag="${TAG}" ${HELM_SECRETS_ARGS} --timeout ${HELM_TIMEOUT} ${HELM_EXTRA_ARGS} || (helm status "${RELEASE}" --namespace "${NS}" && exit 1)
          fi

      - name: Success
        run: echo "Helm deploy succeeded ✅"
